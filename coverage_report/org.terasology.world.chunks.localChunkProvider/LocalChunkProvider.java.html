<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalChunkProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Terasology$engine_tests_with_JaCoCo.exec</a> &gt; <a href="index.source.html" class="el_package">org.terasology.world.chunks.localChunkProvider</a> &gt; <span class="el_source">LocalChunkProvider.java</span></div><h1>LocalChunkProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2018 MovingBlocks
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.terasology.world.chunks.localChunkProvider;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Queues;
import com.google.common.collect.Sets;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.TShortObjectMap;
import gnu.trove.map.hash.TShortObjectHashMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.terasology.entitySystem.Component;
import org.terasology.entitySystem.entity.EntityManager;
import org.terasology.entitySystem.entity.EntityRef;
import org.terasology.entitySystem.entity.EntityStore;
import org.terasology.entitySystem.prefab.Prefab;
import org.terasology.math.ChunkMath;
import org.terasology.math.Region3i;
import org.terasology.math.Side;
import org.terasology.math.TeraMath;
import org.terasology.math.geom.Vector3i;
import org.terasology.monitoring.PerformanceMonitor;
import org.terasology.monitoring.chunk.ChunkMonitor;
import org.terasology.persistence.ChunkStore;
import org.terasology.persistence.StorageManager;
import org.terasology.utilities.concurrency.TaskMaster;
import org.terasology.world.BlockEntityRegistry;
import org.terasology.world.block.BeforeDeactivateBlocks;
import org.terasology.world.block.Block;
import org.terasology.world.block.BlockManager;
import org.terasology.world.block.OnActivatedBlocks;
import org.terasology.world.block.OnAddedBlocks;
import org.terasology.world.chunks.Chunk;
import org.terasology.world.chunks.ChunkBlockIterator;
import org.terasology.world.chunks.ChunkConstants;
import org.terasology.world.chunks.ChunkRegionListener;
import org.terasology.world.chunks.ManagedChunk;
import org.terasology.world.chunks.blockdata.ExtraBlockDataManager;
import org.terasology.world.chunks.event.BeforeChunkUnload;
import org.terasology.world.chunks.event.OnChunkGenerated;
import org.terasology.world.chunks.event.OnChunkLoaded;
import org.terasology.world.chunks.event.PurgeWorldEvent;
import org.terasology.world.chunks.internal.ChunkImpl;
import org.terasology.world.chunks.internal.ChunkRelevanceRegion;
import org.terasology.world.chunks.internal.GeneratingChunkProvider;
import org.terasology.world.chunks.internal.ReadyChunkInfo;
import org.terasology.world.chunks.pipeline.AbstractChunkTask;
import org.terasology.world.chunks.pipeline.ChunkGenerationPipeline;
import org.terasology.world.chunks.pipeline.ChunkTask;
import org.terasology.world.generation.impl.EntityBufferImpl;
import org.terasology.world.generator.WorldGenerator;
import org.terasology.world.internal.ChunkViewCore;
import org.terasology.world.internal.ChunkViewCoreImpl;
import org.terasology.world.propagation.light.InternalLightProcessor;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Supplier;

/**
 */
public class LocalChunkProvider implements GeneratingChunkProvider {

<span class="fc" id="L90">    private static final Logger logger = LoggerFactory.getLogger(LocalChunkProvider.class);</span>
    private static final int UNLOAD_PER_FRAME = 64;
<span class="fc" id="L92">    private static final Vector3i UNLOAD_LEEWAY = Vector3i.one();</span>

    private StorageManager storageManager;
    private final EntityManager entityManager;

    private ChunkGenerationPipeline pipeline;
    private TaskMaster&lt;ChunkUnloadRequest&gt; unloadRequestTaskMaster;
    private WorldGenerator generator;

<span class="fc" id="L101">    private Map&lt;EntityRef, ChunkRelevanceRegion&gt; regions = Maps.newHashMap();</span>


<span class="fc" id="L104">    private final Set&lt;Vector3i&gt; preparingChunks = Sets.newHashSet();</span>
<span class="fc" id="L105">    private final BlockingQueue&lt;ReadyChunkInfo&gt; readyChunks = Queues.newLinkedBlockingQueue();</span>
<span class="fc" id="L106">    private List&lt;ReadyChunkInfo&gt; sortedReadyChunks = Lists.newArrayList();</span>
<span class="fc" id="L107">    private final BlockingQueue&lt;TShortObjectMap&lt;TIntList&gt;&gt; deactivateBlocksQueue = Queues.newLinkedBlockingQueue();</span>

<span class="fc" id="L109">    private EntityRef worldEntity = EntityRef.NULL;</span>

<span class="fc" id="L111">    private ReadWriteLock regionLock = new ReentrantReadWriteLock();</span>

    private BlockManager blockManager;
    private ExtraBlockDataManager extraDataManager;
    private final ChunkCache chunkCache;
    private final Supplier&lt;ChunkFinalizer&gt; chunkFinalizerSupplier;
    private BlockEntityRegistry registry;

    private ChunkFinalizer chunkFinalizer;

    //TODO Remove this old constructor at the end of the chunk overhaul
    public LocalChunkProvider(StorageManager storageManager, EntityManager entityManager, WorldGenerator generator,
                              BlockManager blockManager, ExtraBlockDataManager extraDataManager) {
<span class="nc" id="L124">        this(storageManager,</span>
                entityManager,
                generator,
                blockManager,
                extraDataManager,
                new LightMergingChunkFinalizer(),
                LightMergingChunkFinalizer::new,
                new ConcurrentMapChunkCache());
<span class="nc" id="L132">    }</span>

    LocalChunkProvider(StorageManager storageManager, EntityManager entityManager, WorldGenerator generator,
                       BlockManager blockManager, ExtraBlockDataManager extraDataManager,
                       ChunkFinalizer chunkFinalizer, Supplier&lt;ChunkFinalizer&gt; chunkFinalizerSupplier,
<span class="fc" id="L137">                       ChunkCache chunkCache) {</span>
<span class="fc" id="L138">        this.storageManager = storageManager;</span>
<span class="fc" id="L139">        this.entityManager = entityManager;</span>
<span class="fc" id="L140">        this.generator = generator;</span>
<span class="fc" id="L141">        this.blockManager = blockManager;</span>
<span class="fc" id="L142">        this.extraDataManager = extraDataManager;</span>
<span class="fc" id="L143">        this.pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());</span>
<span class="fc" id="L144">        this.unloadRequestTaskMaster = TaskMaster.createFIFOTaskMaster(&quot;Chunk-Unloader&quot;, 4);</span>
<span class="fc" id="L145">        this.chunkFinalizer = chunkFinalizer;</span>
<span class="fc" id="L146">        this.chunkCache = chunkCache;</span>
<span class="fc" id="L147">        chunkFinalizer.initialize(this);</span>
<span class="fc" id="L148">        this.chunkFinalizerSupplier = chunkFinalizerSupplier;</span>
<span class="fc" id="L149">        ChunkMonitor.fireChunkProviderInitialized(this);</span>
<span class="fc" id="L150">    }</span>


    public void setBlockEntityRegistry(BlockEntityRegistry value) {
<span class="fc" id="L154">        this.registry = value;</span>
<span class="fc" id="L155">    }</span>

    @Override
    public ChunkViewCore getLocalView(Vector3i centerChunkPos) {
<span class="nc" id="L159">        Region3i region = Region3i.createFromCenterExtents(centerChunkPos, ChunkConstants.LOCAL_REGION_EXTENTS);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (getChunk(centerChunkPos) != null) {</span>
<span class="nc" id="L161">            return createWorldView(region, Vector3i.one());</span>
        }
<span class="nc" id="L163">        return null;</span>
    }

    @Override
    public ChunkViewCore getSubviewAroundBlock(Vector3i blockPos, int extent) {
<span class="nc" id="L168">        Region3i region = ChunkMath.getChunkRegionAroundWorldPos(blockPos, extent);</span>
<span class="nc" id="L169">        return createWorldView(region, new Vector3i(-region.min().x, -region.min().y, -region.min().z));</span>
    }

    @Override
    public ChunkViewCore getSubviewAroundChunk(Vector3i chunkPos) {
<span class="nc" id="L174">        Region3i region = Region3i.createFromCenterExtents(chunkPos, ChunkConstants.LOCAL_REGION_EXTENTS);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (getChunk(chunkPos) != null) {</span>
<span class="nc" id="L176">            return createWorldView(region, new Vector3i(-region.min().x, -region.min().y, -region.min().z));</span>
        }
<span class="nc" id="L178">        return null;</span>
    }

    private ChunkViewCore createWorldView(Region3i region, Vector3i offset) {
<span class="nc" id="L182">        Chunk[] chunks = new Chunk[region.sizeX() * region.sizeY() * region.sizeZ()];</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        for (Vector3i chunkPos : region) {</span>
<span class="nc" id="L184">            Chunk chunk = chunkCache.get(chunkPos);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (chunk == null) {</span>
<span class="nc" id="L186">                return null;</span>
            }
<span class="nc" id="L188">            chunkPos.sub(region.minX(), region.minY(), region.minZ());</span>
<span class="nc" id="L189">            int index = TeraMath.calculate3DArrayIndex(chunkPos, region.size());</span>
<span class="nc" id="L190">            chunks[index] = chunk;</span>
<span class="nc" id="L191">        }</span>
<span class="nc" id="L192">        return new ChunkViewCoreImpl(chunks, region, offset, blockManager.getBlock(BlockManager.AIR_ID));</span>
    }

    @Override
    public void setWorldEntity(EntityRef worldEntity) {
<span class="fc" id="L197">        this.worldEntity = worldEntity;</span>
<span class="fc" id="L198">    }</span>

    @Override
    public void addRelevanceEntity(EntityRef entity, Vector3i distance) {
<span class="nc" id="L202">        addRelevanceEntity(entity, distance, null);</span>
<span class="nc" id="L203">    }</span>

    @Override
    public void addRelevanceEntity(EntityRef entity, Vector3i distance, ChunkRegionListener listener) {
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (!entity.exists()) {</span>
<span class="nc" id="L208">            return;</span>
        }
<span class="nc" id="L210">        regionLock.readLock().lock();</span>
        try {
<span class="nc" id="L212">            ChunkRelevanceRegion region = regions.get(entity);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (region != null) {</span>
<span class="nc" id="L214">                region.setRelevanceDistance(distance);</span>
<span class="nc" id="L215">                return;</span>
            }
        } finally {
<span class="nc" id="L218">            regionLock.readLock().unlock();</span>
        }
<span class="nc" id="L220">        ChunkRelevanceRegion region = new ChunkRelevanceRegion(entity, distance);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L222">            region.setListener(listener);</span>
        }
<span class="nc" id="L224">        regionLock.writeLock().lock();</span>
        try {
<span class="nc" id="L226">            regions.put(entity, region);</span>
        } finally {
<span class="nc" id="L228">            regionLock.writeLock().unlock();</span>
        }
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (Vector3i pos : region.getCurrentRegion()) {</span>
<span class="nc" id="L231">            Chunk chunk = getChunk(pos);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (chunk != null) {</span>
<span class="nc" id="L233">                region.checkIfChunkIsRelevant(chunk);</span>
            } else {
<span class="nc" id="L235">                createOrLoadChunk(pos);</span>
            }
<span class="nc" id="L237">        }</span>
<span class="nc" id="L238">    }</span>

    @Override
    public void updateRelevanceEntity(EntityRef entity, Vector3i distance) {
<span class="nc" id="L242">        regionLock.readLock().lock();</span>
        try {
<span class="nc" id="L244">            ChunkRelevanceRegion region = regions.get(entity);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (region != null) {</span>
<span class="nc" id="L246">                region.setRelevanceDistance(distance);</span>
            }
        } finally {
<span class="nc" id="L249">            regionLock.readLock().unlock();</span>
        }
<span class="nc" id="L251">    }</span>

    @Override
    public void removeRelevanceEntity(EntityRef entity) {
<span class="nc" id="L255">        regionLock.writeLock().lock();</span>
        try {
<span class="nc" id="L257">            regions.remove(entity);</span>
        } finally {
<span class="nc" id="L259">            regionLock.writeLock().unlock();</span>
        }
<span class="nc" id="L261">    }</span>

    @Override
    public void completeUpdate() {
<span class="fc" id="L265">        List&lt;ReadyChunkInfo&gt; readyChunkInfos = chunkFinalizer.completeFinalization();</span>
<span class="fc" id="L266">        readyChunkInfos.forEach(this::processReadyChunk);</span>
<span class="fc" id="L267">    }</span>

    private void processReadyChunk(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L270">        updateChunkReadinessState(readyChunkInfo);</span>
        //TODO, it is not clear if the activate/addedBlocks event logic is correct.
        //See https://github.com/MovingBlocks/Terasology/issues/3244
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (readyChunkInfo.isNewChunk()) {</span>
<span class="fc" id="L274">            generateQueuedEntities(readyChunkInfo);</span>
<span class="fc" id="L275">            sendOnActivatedBlocks(readyChunkInfo);</span>
<span class="fc" id="L276">            sendOnChunkGenerated(readyChunkInfo);</span>
        } else {
<span class="fc" id="L278">            readyChunkInfo.getChunkStore().restoreEntities();</span>
<span class="fc" id="L279">            sendOnAddedBlocks(readyChunkInfo);</span>
<span class="fc" id="L280">            sendOnActivatedBlocks(readyChunkInfo);</span>
        }
<span class="fc" id="L282">        sendOnChunkLoaded(readyChunkInfo);</span>
<span class="fc" id="L283">    }</span>

    private OnChunkLoaded sendOnChunkLoaded(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L286">        return worldEntity.send(new OnChunkLoaded(readyChunkInfo.getPos()));</span>
    }

    private void sendOnChunkGenerated(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L290">        worldEntity.send(new OnChunkGenerated(readyChunkInfo.getPos()));</span>
<span class="fc" id="L291">    }</span>

    private void sendOnActivatedBlocks(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L294">        PerformanceMonitor.startActivity(&quot;Sending OnActivateBlocks&quot;);</span>
<span class="fc" id="L295">        readyChunkInfo.getBlockPositionMapppings().forEachEntry((id, positions) -&gt; {</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">            if (positions.size() &gt; 0) {</span>
<span class="fc" id="L297">                blockManager.getBlock(id).getEntity().send(new OnActivatedBlocks(positions, registry));</span>
            }
<span class="fc" id="L299">            return true;</span>
        });
<span class="fc" id="L301">        PerformanceMonitor.endActivity();</span>
<span class="fc" id="L302">    }</span>

    private void sendOnAddedBlocks(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L305">        PerformanceMonitor.startActivity(&quot;Sending OnAddedBlocks&quot;);</span>
<span class="fc" id="L306">        readyChunkInfo.getBlockPositionMapppings().forEachEntry((id, positions) -&gt; {</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            if (positions.size() &gt; 0) {</span>
<span class="fc" id="L308">                blockManager.getBlock(id).getEntity().send(new OnAddedBlocks(positions, registry));</span>
            }
<span class="fc" id="L310">            return true;</span>
        });
<span class="fc" id="L312">        PerformanceMonitor.endActivity();</span>
<span class="fc" id="L313">    }</span>

    private void generateQueuedEntities(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L316">        PerformanceMonitor.startActivity(&quot;Generating queued Entities&quot;);</span>
<span class="fc" id="L317">        readyChunkInfo.getEntities().forEach(this::generateQueuedEntities);</span>
<span class="fc" id="L318">        PerformanceMonitor.endActivity();</span>
<span class="fc" id="L319">    }</span>

    private void updateChunkReadinessState(final ReadyChunkInfo readyChunkInfo) {
<span class="fc" id="L322">        Chunk chunk = readyChunkInfo.getChunk();</span>
<span class="fc" id="L323">        chunk.markReady();</span>
<span class="fc" id="L324">    }</span>

    private void generateQueuedEntities(EntityStore store) {
<span class="fc" id="L327">        Prefab prefab = store.getPrefab();</span>
        EntityRef entity;
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (prefab != null) {</span>
<span class="fc" id="L330">            entity = entityManager.create(prefab);</span>
        } else {
<span class="fc" id="L332">            entity = entityManager.create();</span>
        }
<span class="fc bfc" id="L334" title="All 2 branches covered.">        for (Component component : store.iterateComponents()) {</span>
<span class="fc" id="L335">            entity.addComponent(component);</span>
<span class="fc" id="L336">        }</span>
<span class="fc" id="L337">    }</span>

    @Override
    public void beginUpdate() {
<span class="nc" id="L341">        regionLock.readLock().lock();</span>
        try {
<span class="nc" id="L343">            updateRelevance();</span>
<span class="nc" id="L344">            deactivateBlocks();</span>
<span class="nc" id="L345">            checkForUnload();</span>
<span class="nc" id="L346">            makeChunksAvailable();</span>
        } finally {
<span class="nc" id="L348">            regionLock.readLock().unlock();</span>
        }
<span class="nc" id="L350">    }</span>

    private void makeChunksAvailable() {
<span class="nc" id="L353">        List&lt;ReadyChunkInfo&gt; newReadyChunks = Lists.newArrayListWithExpectedSize(readyChunks.size());</span>
<span class="nc" id="L354">        readyChunks.drainTo(newReadyChunks);</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">        for (ReadyChunkInfo readyChunkInfo : newReadyChunks) {</span>
<span class="nc" id="L356">            chunkCache.put(readyChunkInfo.getPos(), readyChunkInfo.getChunk());</span>
<span class="nc" id="L357">            preparingChunks.remove(readyChunkInfo.getPos());</span>
<span class="nc" id="L358">        }</span>
<span class="nc" id="L359">        updateRelevanceRegionsWithNewChunks(newReadyChunks);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (!newReadyChunks.isEmpty()) {</span>
<span class="nc" id="L361">            sortedReadyChunks.addAll(newReadyChunks);</span>
<span class="nc" id="L362">            Collections.sort(sortedReadyChunks, new ReadyChunkRelevanceComparator());</span>
        }
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (!sortedReadyChunks.isEmpty()) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            for (int i = sortedReadyChunks.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L366">                ReadyChunkInfo chunkInfo = sortedReadyChunks.get(i);</span>
<span class="nc" id="L367">                PerformanceMonitor.startActivity(&quot;Make Chunk Available&quot;);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                if (makeChunkAvailable(chunkInfo)) {</span>
<span class="nc" id="L369">                    sortedReadyChunks.remove(i);</span>
                }
<span class="nc" id="L371">                PerformanceMonitor.endActivity();</span>
            }
        }
<span class="nc" id="L374">    }</span>

    private void updateRelevanceRegionsWithNewChunks(List&lt;ReadyChunkInfo&gt; newReadyChunks) {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        for (ReadyChunkInfo readyChunkInfo : newReadyChunks) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            for (ChunkRelevanceRegion region : regions.values()) {</span>
<span class="nc" id="L379">                region.checkIfChunkIsRelevant(readyChunkInfo.getChunk());</span>
<span class="nc" id="L380">            }</span>
<span class="nc" id="L381">        }</span>
<span class="nc" id="L382">    }</span>

    private void deactivateBlocks() {
<span class="nc" id="L385">        List&lt;TShortObjectMap&lt;TIntList&gt;&gt; deactivatedBlockSets = Lists.newArrayListWithExpectedSize(deactivateBlocksQueue.size());</span>
<span class="nc" id="L386">        deactivateBlocksQueue.drainTo(deactivatedBlockSets);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (TShortObjectMap&lt;TIntList&gt; deactivatedBlockSet : deactivatedBlockSets) {</span>
<span class="nc" id="L388">            deactivatedBlockSet.forEachEntry((id, positions) -&gt; {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (positions.size() &gt; 0) {</span>
<span class="nc" id="L390">                    blockManager.getBlock(id).getEntity().send(new BeforeDeactivateBlocks(positions, registry));</span>
                }
<span class="nc" id="L392">                return true;</span>
            });
<span class="nc" id="L394">        }</span>
<span class="nc" id="L395">    }</span>

    private void checkForUnload() {
<span class="nc" id="L398">        PerformanceMonitor.startActivity(&quot;Unloading irrelevant chunks&quot;);</span>
<span class="nc" id="L399">        int unloaded = 0;</span>
<span class="nc" id="L400">        logger.debug(&quot;Compacting cache&quot;);</span>
<span class="nc" id="L401">        Iterator&lt;Vector3i&gt; iterator = chunkCache.iterateChunkPositions();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        while (iterator.hasNext()) {</span>
<span class="nc" id="L403">            Vector3i pos = iterator.next();</span>
<span class="nc" id="L404">            boolean keep = false;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            for (ChunkRelevanceRegion region : regions.values()) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (region.getCurrentRegion().expand(UNLOAD_LEEWAY).encompasses(pos)) {</span>
<span class="nc" id="L407">                    keep = true;</span>
<span class="nc" id="L408">                    break;</span>
                }
<span class="nc" id="L410">            }</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (!keep) {</span>
                // TODO: need some way to not dispose chunks being edited or processed (or do so safely)
                // Note: Above won't matter if all changes are on the main thread
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (unloadChunkInternal(pos)) {</span>
<span class="nc" id="L415">                    iterator.remove();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    if (++unloaded &gt;= UNLOAD_PER_FRAME) {</span>
<span class="nc" id="L417">                        break;</span>
                    }
                }
            }
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">        PerformanceMonitor.endActivity();</span>
<span class="nc" id="L423">    }</span>

    private boolean unloadChunkInternal(Vector3i pos) {
<span class="nc" id="L426">        Chunk chunk = chunkCache.get(pos);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (!chunk.isReady()) {</span>
            // Chunk hasn't been finished or changed, so just drop it.
<span class="nc" id="L429">            Iterator&lt;ReadyChunkInfo&gt; infoIterator = sortedReadyChunks.iterator();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">            while (infoIterator.hasNext()) {</span>
<span class="nc" id="L431">                ReadyChunkInfo next = infoIterator.next();</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (next.getPos().equals(chunk.getPosition())) {</span>
<span class="nc" id="L433">                    infoIterator.remove();</span>
<span class="nc" id="L434">                    break;</span>
                }
<span class="nc" id="L436">            }</span>
<span class="nc" id="L437">            return true;</span>
        }
<span class="nc" id="L439">        worldEntity.send(new BeforeChunkUnload(pos));</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        for (ChunkRelevanceRegion region : regions.values()) {</span>
<span class="nc" id="L441">            region.chunkUnloaded(pos);</span>
<span class="nc" id="L442">        }</span>
<span class="nc" id="L443">        storageManager.deactivateChunk(chunk);</span>
<span class="nc" id="L444">        chunk.dispose();</span>

        try {
<span class="nc" id="L447">            unloadRequestTaskMaster.put(new ChunkUnloadRequest(chunk, this));</span>
<span class="nc" id="L448">        } catch (InterruptedException e) {</span>
<span class="nc" id="L449">            logger.error(&quot;Failed to enqueue unload request for {}&quot;, chunk.getPosition(), e);</span>
<span class="nc" id="L450">        }</span>

<span class="nc" id="L452">        return true;</span>
    }

    private boolean areAdjacentChunksReady(Chunk chunk) {
<span class="nc bnc" id="L456" title="All 2 branches missed.">        for (Chunk adjacentChunk : listAdjacentChunks(chunk)) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (!adjacentChunk.isReady()) {</span>
<span class="nc" id="L458">                return false;</span>
            }
<span class="nc" id="L460">        }</span>
<span class="nc" id="L461">        return true;</span>
    }

    private List&lt;Chunk&gt; listAdjacentChunks(Chunk chunk) {
<span class="nc" id="L465">        final Vector3i centerChunkPosition = chunk.getPosition();</span>
<span class="nc" id="L466">        List&lt;Chunk&gt; adjacentChunks = new ArrayList&lt;&gt;(6);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        for (Side side : Side.getAllSides()) {</span>
<span class="nc" id="L468">            final Vector3i adjacentChunkPosition = side.getAdjacentPos(centerChunkPosition);</span>
<span class="nc" id="L469">            final Chunk adjacentChunk = chunkCache.get(adjacentChunkPosition);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (adjacentChunk != null) {</span>
<span class="nc" id="L471">                adjacentChunks.add(adjacentChunk);</span>
            }
<span class="nc" id="L473">        }</span>
<span class="nc" id="L474">        return adjacentChunks;</span>
    }

    private void updateRelevance() {
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (ChunkRelevanceRegion chunkRelevanceRegion : regions.values()) {</span>
<span class="nc" id="L479">            chunkRelevanceRegion.update();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">            if (chunkRelevanceRegion.isDirty()) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                for (Vector3i pos : chunkRelevanceRegion.getNeededChunks()) {</span>
<span class="nc" id="L482">                    Chunk chunk = chunkCache.get(pos);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                    if (chunk != null) {</span>
<span class="nc" id="L484">                        chunkRelevanceRegion.checkIfChunkIsRelevant(chunk);</span>
                    } else {
<span class="nc" id="L486">                        createOrLoadChunk(pos);</span>
                    }
<span class="nc" id="L488">                }</span>
<span class="nc" id="L489">                chunkRelevanceRegion.setUpToDate();</span>
            }
<span class="nc" id="L491">        }</span>
<span class="nc" id="L492">    }</span>

    private boolean makeChunkAvailable(final ReadyChunkInfo readyChunkInfo) {
<span class="nc" id="L495">        final Chunk chunk = chunkCache.get(readyChunkInfo.getPos());</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (chunk == null) {</span>
<span class="nc" id="L497">            return false;</span>
        }
<span class="nc bnc" id="L499" title="All 2 branches missed.">        for (Vector3i pos : Region3i.createFromCenterExtents(readyChunkInfo.getPos(), 1)) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (chunkCache.get(pos) == null) {</span>
<span class="nc" id="L501">                return false;</span>
            }
<span class="nc" id="L503">        }</span>
<span class="nc" id="L504">        chunkFinalizer.beginFinalization(chunk, readyChunkInfo);</span>
<span class="nc" id="L505">        return true;</span>
    }

    void gatherBlockPositionsForDeactivate(Chunk chunk) {
        try {
<span class="nc" id="L510">            deactivateBlocksQueue.put(createBatchBlockEventMappings(chunk));</span>
<span class="nc" id="L511">        } catch (InterruptedException e) {</span>
<span class="nc" id="L512">            logger.error(&quot;Failed to queue deactivation of blocks for {}&quot;, chunk.getPosition());</span>
<span class="nc" id="L513">        }</span>
<span class="nc" id="L514">    }</span>

    private TShortObjectMap&lt;TIntList&gt; createBatchBlockEventMappings(Chunk chunk) {
<span class="nc" id="L517">        TShortObjectMap&lt;TIntList&gt; batchBlockMap = new TShortObjectHashMap&lt;&gt;();</span>
<span class="nc" id="L518">        blockManager.listRegisteredBlocks().stream().filter(Block::isLifecycleEventsRequired).forEach(block -&gt;</span>
<span class="nc" id="L519">                batchBlockMap.put(block.getId(), new TIntArrayList()));</span>

<span class="nc" id="L521">        ChunkBlockIterator i = chunk.getBlockIterator();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        while (i.next()) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            if (i.getBlock().isLifecycleEventsRequired()) {</span>
<span class="nc" id="L524">                TIntList positionList = batchBlockMap.get(i.getBlock().getId());</span>
<span class="nc" id="L525">                positionList.add(i.getBlockPos().x);</span>
<span class="nc" id="L526">                positionList.add(i.getBlockPos().y);</span>
<span class="nc" id="L527">                positionList.add(i.getBlockPos().z);</span>
<span class="nc" id="L528">            }</span>
        }
<span class="nc" id="L530">        return batchBlockMap;</span>
    }

    @Override
    public Chunk getChunk(int x, int y, int z) {
<span class="nc" id="L535">        return getChunk(new Vector3i(x, y, z));</span>
    }

    @Override
    public Chunk getChunk(Vector3i pos) {
<span class="nc" id="L540">        Chunk chunk = chunkCache.get(pos);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (isChunkReady(chunk)) {</span>
<span class="nc" id="L542">            return chunk;</span>
        }
<span class="nc" id="L544">        return null;</span>
    }

    @Override
    public Collection&lt;Chunk&gt; getAllChunks() {
<span class="nc" id="L549">        return chunkCache.getAllChunks();</span>
    }


    @Override
    public void restart() {
<span class="nc" id="L555">        pipeline.restart();</span>
<span class="nc" id="L556">        unloadRequestTaskMaster.restart();</span>
<span class="nc" id="L557">        chunkFinalizer.restart();</span>
<span class="nc" id="L558">    }</span>

    @Override
    public void shutdown() {
<span class="nc" id="L562">        pipeline.shutdown();</span>
<span class="nc" id="L563">        unloadRequestTaskMaster.shutdown(new ChunkUnloadRequest(), true);</span>
<span class="nc" id="L564">        chunkFinalizer.shutdown();</span>
<span class="nc" id="L565">    }</span>

    @Override
    public void dispose() {
<span class="nc" id="L569">        shutdown();</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">        for (Chunk chunk : chunkCache.getAllChunks()) {</span>
<span class="nc" id="L572">            unloadChunkInternal(chunk.getPosition());</span>
<span class="nc" id="L573">            chunk.dispose();</span>
<span class="nc" id="L574">        }</span>
<span class="nc" id="L575">        chunkCache.clear();</span>
        /*
         * The chunk monitor needs to clear chunk references, so it's important
         * that no new chunk get created
         */
<span class="nc" id="L580">        ChunkMonitor.fireChunkProviderDisposed(this);</span>
<span class="nc" id="L581">    }</span>

    @Override
    public boolean reloadChunk(Vector3i coords) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (!chunkCache.containsChunkAt(coords)) {</span>
<span class="nc" id="L586">            return false;</span>
        }

<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (unloadChunkInternal(coords)) {</span>
<span class="nc" id="L590">            chunkCache.removeChunkAt(coords);</span>
<span class="nc" id="L591">            createOrLoadChunk(coords);</span>
<span class="nc" id="L592">            return true;</span>
        }

<span class="nc" id="L595">        return false;</span>
    }

    @Override
    public void purgeWorld() {
<span class="nc" id="L600">        ChunkMonitor.fireChunkProviderDisposed(this);</span>
<span class="nc" id="L601">        pipeline.shutdown();</span>
<span class="nc" id="L602">        unloadRequestTaskMaster.shutdown(new ChunkUnloadRequest(), true);</span>
<span class="nc" id="L603">        chunkFinalizer.shutdown();</span>

<span class="nc" id="L605">        chunkCache.getAllChunks().stream().filter(ManagedChunk::isReady).forEach(chunk -&gt; {</span>
<span class="nc" id="L606">            worldEntity.send(new BeforeChunkUnload(chunk.getPosition()));</span>
<span class="nc" id="L607">            storageManager.deactivateChunk(chunk);</span>
<span class="nc" id="L608">            chunk.dispose();</span>
<span class="nc" id="L609">        });</span>
<span class="nc" id="L610">        chunkCache.clear();</span>
<span class="nc" id="L611">        readyChunks.clear();</span>
<span class="nc" id="L612">        sortedReadyChunks.clear();</span>
<span class="nc" id="L613">        storageManager.deleteWorld();</span>
<span class="nc" id="L614">        preparingChunks.clear();</span>
<span class="nc" id="L615">        worldEntity.send(new PurgeWorldEvent());</span>

<span class="nc" id="L617">        pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());</span>
<span class="nc" id="L618">        unloadRequestTaskMaster = TaskMaster.createFIFOTaskMaster(&quot;Chunk-Unloader&quot;, 8);</span>
<span class="nc" id="L619">        chunkFinalizer = chunkFinalizerSupplier.get();</span>
<span class="nc" id="L620">        chunkFinalizer.initialize(this);</span>
<span class="nc" id="L621">        chunkFinalizer.restart();</span>
<span class="nc" id="L622">        ChunkMonitor.fireChunkProviderInitialized(this);</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">        for (ChunkRelevanceRegion chunkRelevanceRegion : regions.values()) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            for (Vector3i pos : chunkRelevanceRegion.getCurrentRegion()) {</span>
<span class="nc" id="L626">                createOrLoadChunk(pos);</span>
<span class="nc" id="L627">            }</span>
<span class="nc" id="L628">            chunkRelevanceRegion.setUpToDate();</span>
<span class="nc" id="L629">        }</span>
<span class="nc" id="L630">    }</span>

    private void createOrLoadChunk(Vector3i chunkPos) {
<span class="nc" id="L633">        Chunk chunk = chunkCache.get(chunkPos);</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">        if (chunk == null &amp;&amp; !preparingChunks.contains(chunkPos)) {</span>
<span class="nc" id="L635">            preparingChunks.add(chunkPos);</span>
<span class="nc" id="L636">            pipeline.doTask(new AbstractChunkTask(chunkPos) {</span>
                @Override
                public String getName() {
<span class="nc" id="L639">                    return &quot;Create or Load Chunk&quot;;</span>
                }

                @Override
                public void run() {
<span class="nc" id="L644">                    ChunkStore chunkStore = storageManager.loadChunkStore(getPosition());</span>
                    Chunk chunk;
<span class="nc" id="L646">                    EntityBufferImpl buffer = new EntityBufferImpl();</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">                    if (chunkStore == null) {</span>
<span class="nc" id="L648">                        chunk = new ChunkImpl(getPosition(), blockManager, extraDataManager);</span>
<span class="nc" id="L649">                        generator.createChunk(chunk, buffer);</span>
                    } else {
<span class="nc" id="L651">                        chunk = chunkStore.getChunk();</span>
                    }

<span class="nc" id="L654">                    InternalLightProcessor.generateInternalLighting(chunk);</span>
<span class="nc" id="L655">                    chunk.deflate();</span>
<span class="nc" id="L656">                    TShortObjectMap&lt;TIntList&gt; mappings = createBatchBlockEventMappings(chunk);</span>
<span class="nc" id="L657">                    readyChunks.offer(new ReadyChunkInfo(chunk, mappings, chunkStore, buffer.getAll()));</span>
<span class="nc" id="L658">                }</span>
            });
        }
<span class="nc" id="L661">    }</span>


    @Override
    public void onChunkIsReady(Chunk chunk) {
<span class="nc" id="L666">        readyChunks.offer(new ReadyChunkInfo(chunk, createBatchBlockEventMappings(chunk), Collections.emptyList()));</span>
<span class="nc" id="L667">    }</span>

    @Override
    public Chunk getChunkUnready(Vector3i pos) {
<span class="nc" id="L671">        return chunkCache.get(pos);</span>
    }

    @Override
    public boolean isChunkReady(Vector3i pos) {
<span class="nc" id="L676">        return isChunkReady(chunkCache.get(pos));</span>
    }

    private boolean isChunkReady(Chunk chunk) {
<span class="nc bnc" id="L680" title="All 4 branches missed.">        return chunk != null &amp;&amp; chunk.isReady();</span>
    }

<span class="fc" id="L683">    private class ChunkTaskRelevanceComparator implements Comparator&lt;ChunkTask&gt; {</span>

        @Override
        public int compare(ChunkTask o1, ChunkTask o2) {
<span class="nc" id="L687">            return score(o1) - score(o2);</span>
        }

        private int score(ChunkTask task) {
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (task.isTerminateSignal()) {</span>
<span class="nc" id="L692">                return -1;</span>
            }
<span class="nc" id="L694">            return score(task.getPosition());</span>
        }

        private int score(Vector3i chunk) {
<span class="nc" id="L698">            int score = Integer.MAX_VALUE;</span>

<span class="nc" id="L700">            regionLock.readLock().lock();</span>
            try {
<span class="nc bnc" id="L702" title="All 2 branches missed.">                for (ChunkRelevanceRegion region : regions.values()) {</span>
<span class="nc" id="L703">                    int dist = distFromRegion(chunk, region.getCenter());</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                    if (dist &lt; score) {</span>
<span class="nc" id="L705">                        score = dist;</span>
                    }
<span class="nc" id="L707">                }</span>
<span class="nc" id="L708">                return score;</span>
            } finally {
<span class="nc" id="L710">                regionLock.readLock().unlock();</span>
            }
        }

        private int distFromRegion(Vector3i pos, Vector3i regionCenter) {
<span class="nc" id="L715">            return pos.gridDistance(regionCenter);</span>
        }
    }

<span class="nc" id="L719">    private class ReadyChunkRelevanceComparator implements Comparator&lt;ReadyChunkInfo&gt; {</span>

        @Override
        public int compare(ReadyChunkInfo o1, ReadyChunkInfo o2) {
<span class="nc" id="L723">            return score(o2.getPos()) - score(o1.getPos());</span>
        }

        private int score(Vector3i chunk) {
<span class="nc" id="L727">            int score = Integer.MAX_VALUE;</span>

<span class="nc" id="L729">            regionLock.readLock().lock();</span>
            try {
<span class="nc bnc" id="L731" title="All 2 branches missed.">                for (ChunkRelevanceRegion region : regions.values()) {</span>
<span class="nc" id="L732">                    int dist = distFromRegion(chunk, region.getCenter());</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                    if (dist &lt; score) {</span>
<span class="nc" id="L734">                        score = dist;</span>
                    }
<span class="nc" id="L736">                }</span>
<span class="nc" id="L737">                return score;</span>
            } finally {
<span class="nc" id="L739">                regionLock.readLock().unlock();</span>
            }
        }

        private int distFromRegion(Vector3i pos, Vector3i regionCenter) {
<span class="nc" id="L744">            return pos.gridDistance(regionCenter);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>