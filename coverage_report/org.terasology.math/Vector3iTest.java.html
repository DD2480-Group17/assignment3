<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Vector3iTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Terasology$engine_tests_with_JaCoCo.exec</a> &gt; <a href="index.source.html" class="el_package">org.terasology.math</a> &gt; <span class="el_source">Vector3iTest.java</span></div><h1>Vector3iTest.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 MovingBlocks
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.terasology.math;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.terasology.math.geom.Vector3f;
import org.terasology.math.geom.Vector3i;

import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

/**
 */
public class Vector3iTest {

    private Vector3i v1;
    private Vector3i v2;
    private Vector3i v3;

<span class="fc" id="L42">    public Vector3iTest() {</span>
<span class="fc" id="L43">    }</span>

    @BeforeAll
    public static void setUpClass() throws Exception {
<span class="fc" id="L47">    }</span>

    @AfterAll
    public static void tearDownClass() throws Exception {
<span class="fc" id="L51">    }</span>

    @BeforeEach
    public void setUp() {
<span class="fc" id="L55">        v1 = new Vector3i(1, 3, 7);</span>
<span class="fc" id="L56">        v2 = new Vector3i(2, 6, 14);</span>
<span class="fc" id="L57">        v3 = new Vector3i(3, 9, 21);</span>
<span class="fc" id="L58">    }</span>

    @AfterEach
    public void tearDown() {
<span class="fc" id="L62">    }</span>

    @Test
    public void testEmptyConstructor() {
<span class="fc" id="L66">        Vector3i v = new Vector3i();</span>
<span class="fc" id="L67">        assertEquals(0, v.x);</span>
<span class="fc" id="L68">        assertEquals(0, v.y);</span>
<span class="fc" id="L69">        assertEquals(0, v.z);</span>
<span class="fc" id="L70">    }</span>

    @Test
    public void testTripleConstructor() {
<span class="fc" id="L74">        Vector3i v = new Vector3i(1, 2, 3);</span>
<span class="fc" id="L75">        assertEquals(1, v.x);</span>
<span class="fc" id="L76">        assertEquals(2, v.y);</span>
<span class="fc" id="L77">        assertEquals(3, v.z);</span>
<span class="fc" id="L78">    }</span>

    @Test
    public void testOffsetConstructor() {
<span class="fc" id="L82">        Vector3f vOrig = new Vector3f(0.1f, 0.6f, 7.2f);</span>
<span class="fc" id="L83">        Vector3i v = new Vector3i(vOrig, 0.5f);</span>
<span class="fc" id="L84">        assertEquals(new Vector3i(0, 1, 7), v);</span>
<span class="fc" id="L85">    }</span>

    @Test
    public void testOffsetConstructorWithNegatives() {
<span class="fc" id="L89">        Vector3f vOrig = new Vector3f(-0.1f, -0.6f, -1.4f);</span>
<span class="fc" id="L90">        Vector3i v = new Vector3i(vOrig, 0.5f);</span>
<span class="fc" id="L91">        assertEquals(new Vector3i(0, -1, -1), v);</span>
<span class="fc" id="L92">    }</span>

    @Test
    public void testCopyConstructor() {
<span class="fc" id="L96">        Vector3i copy = new Vector3i(v1);</span>
<span class="fc" id="L97">        assertEquals(v1.x, copy.x);</span>
<span class="fc" id="L98">        assertEquals(v1.y, copy.y);</span>
<span class="fc" id="L99">        assertEquals(v1.z, copy.z);</span>
<span class="fc" id="L100">    }</span>

    @Test
    public void testEquals() {
<span class="fc" id="L104">        assertFalse(v1.equals(v2));</span>
<span class="fc" id="L105">        assertTrue(v1.equals(new Vector3i(v1.x, v1.y, v1.z)));</span>
<span class="fc" id="L106">        assertFalse(v1.equals(null));</span>
<span class="fc" id="L107">    }</span>

    @Test
    public void testSetTriple() {
<span class="fc" id="L111">        Vector3i v = new Vector3i(v1);</span>
<span class="fc" id="L112">        v.set(v2.x, v2.y, v2.z);</span>
<span class="fc" id="L113">        assertEquals(v2, v);</span>
<span class="fc" id="L114">    }</span>

    @Test
    public void testSetCopy() {
<span class="fc" id="L118">        Vector3i v = new Vector3i();</span>
<span class="fc" id="L119">        v.set(v2);</span>
<span class="fc" id="L120">        assertEquals(v2, v);</span>
<span class="fc" id="L121">    }</span>

    @Test
    public void testAdd() {
<span class="fc" id="L125">        Vector3i v = new Vector3i(v1);</span>
<span class="fc" id="L126">        v.add(v2);</span>
<span class="fc" id="L127">        assertEquals(v3, v);</span>
<span class="fc" id="L128">    }</span>

    @Test
    public void testAddTriple() {
<span class="fc" id="L132">        Vector3i v = new Vector3i(v1);</span>
<span class="fc" id="L133">        v.add(v2.x, v2.y, v2.z);</span>
<span class="fc" id="L134">        assertEquals(v3, v);</span>
<span class="fc" id="L135">    }</span>

    @Test
    public void testMin() {
<span class="fc" id="L139">        Vector3i v = new Vector3i(v1);</span>
<span class="fc" id="L140">        v.min(new Vector3i(v1.z, v1.y, v1.x));</span>
<span class="fc" id="L141">        assertEquals(Math.min(v1.x, v1.z), v.x);</span>
<span class="fc" id="L142">        assertEquals(v1.y, v.y);</span>
<span class="fc" id="L143">        assertEquals(Math.min(v1.x, v1.z), v.z);</span>
<span class="fc" id="L144">    }</span>

    @Test
    public void testMax() {
<span class="fc" id="L148">        Vector3i v = new Vector3i(v1);</span>
<span class="fc" id="L149">        v.max(new Vector3i(v1.z, v1.y, v1.x));</span>
<span class="fc" id="L150">        assertEquals(Math.max(v1.x, v1.z), v.x);</span>
<span class="fc" id="L151">        assertEquals(v1.y, v.y);</span>
<span class="fc" id="L152">        assertEquals(Math.max(v1.x, v1.z), v.z);</span>
<span class="fc" id="L153">    }</span>

    @Test
    public void testManhattanDistance() {
<span class="fc" id="L157">        assertEquals(0, Vector3i.zero().gridDistance(Vector3i.zero()));</span>
<span class="fc" id="L158">        assertEquals(1, Vector3i.zero().gridDistance(Vector3i.west()));</span>
<span class="fc" id="L159">        assertEquals(1, Vector3i.zero().gridDistance(Vector3i.up()));</span>
<span class="fc" id="L160">        assertEquals(1, Vector3i.zero().gridDistance(Vector3i.north()));</span>
<span class="fc" id="L161">        assertEquals(3, Vector3i.zero().gridDistance(Vector3i.one()));</span>
<span class="fc" id="L162">        assertEquals(3, Vector3i.zero().gridDistance(new Vector3i(1, -1, 1)));</span>
<span class="fc" id="L163">    }</span>

    @Test
    public void testHash() {
        // k = 59
        // j = k+1 = 60
        // i = (k+k^2)(1+k)^2 = not important for collision
        // hash = (k+k^2)(1+k)^2 + x(1+k)^2 + (1+k)y + z
        // hash = i + xj^2 + jy + z
        // with x := 0
        // hash = i + jy + z
        // set i + jy + z = i + jy' + z'
        // jy + z = jy' + z'
        // set z' := z + j -&gt; z'-z = j
        // jy = jy' + j -&gt; y' = y - 1
<span class="fc" id="L178">        Vector3i a = new Vector3i(0, 10, 10);</span>
<span class="fc" id="L179">        Vector3i b = new Vector3i(0, 9, 70);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        assertFalse(a.hashCode() == b.hashCode());</span>

<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        assertTrue(new Vector3i(0, 10, 10).hashCode() == new Vector3i(0, 10, 10).hashCode());</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        assertTrue(new Vector3i(-100, 10, 10).hashCode() == new Vector3i(-100, 10, 10).hashCode());</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        assertTrue(new Vector3i(0, -5, -5).hashCode() == new Vector3i(0, -5, -5).hashCode());</span>

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        assertFalse(new Vector3i(1, 10, 10).hashCode() == new Vector3i(0, 10, 10).hashCode());</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        assertFalse(new Vector3i(-101, 10, 10).hashCode() == new Vector3i(-100, 10, 10).hashCode());</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        assertFalse(new Vector3i(0, -1, -5).hashCode() == new Vector3i(0, -5, -5).hashCode());</span>
<span class="fc" id="L189">    }</span>

    @Test
    public void testHashCollisions() {
<span class="fc" id="L193">        int range = 50;</span>

<span class="fc" id="L195">        Set&lt;Integer&gt; alreadyUsedHashes = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (int x = -range; x &lt; range; ++x) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            for (int y = -range; y &lt; range; ++y) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                for (int z = -range; z &lt; range; ++z) {</span>
<span class="fc" id="L200">                    int hash = new Vector3i(x, y, z).hashCode();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                    if (alreadyUsedHashes.contains(hash)) {</span>
<span class="nc" id="L202">                        fail(String.format(&quot;duplicate hash %d at: %d,%d,%d&quot;, hash, x, y, z));</span>
                    } else {
<span class="fc" id="L204">                        alreadyUsedHashes.add(hash);</span>
                    }
                }
            }
        }
<span class="fc" id="L209">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>