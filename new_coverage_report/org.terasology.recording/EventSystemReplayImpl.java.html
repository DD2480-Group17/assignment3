<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EventSystemReplayImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Terasology$engine_tests_with_JaCoCo.exec</a> &gt; <a href="index.source.html" class="el_package">org.terasology.recording</a> &gt; <span class="el_source">EventSystemReplayImpl.java</span></div><h1>EventSystemReplayImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2018 MovingBlocks
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.terasology.recording;

import org.terasology.engine.paths.PathManager;
import org.terasology.entitySystem.entity.internal.EngineEntityManager;
import org.terasology.entitySystem.event.internal.EventReceiver;
import org.terasology.entitySystem.event.internal.EventSystem;
import com.esotericsoftware.reflectasm.MethodAccess;
import com.google.common.base.Objects;
import com.google.common.base.Predicates;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Queues;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import org.reflections.ReflectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.terasology.engine.SimpleUri;
import org.terasology.entitySystem.Component;
import org.terasology.entitySystem.entity.EntityRef;
import org.terasology.entitySystem.event.AbstractConsumableEvent;
import org.terasology.entitySystem.event.ConsumableEvent;
import org.terasology.entitySystem.event.Event;
import org.terasology.entitySystem.event.EventPriority;
import org.terasology.entitySystem.event.ReceiveEvent;
import org.terasology.entitySystem.event.PendingEvent;
import org.terasology.entitySystem.metadata.EventLibrary;
import org.terasology.entitySystem.metadata.EventMetadata;
import org.terasology.entitySystem.systems.ComponentSystem;
import org.terasology.monitoring.PerformanceMonitor;
import org.terasology.network.BroadcastEvent;
import org.terasology.network.Client;
import org.terasology.network.NetworkComponent;
import org.terasology.network.NetworkEvent;
import org.terasology.network.NetworkMode;
import org.terasology.network.NetworkSystem;
import org.terasology.network.OwnerEvent;
import org.terasology.network.ServerEvent;
import org.terasology.world.block.BlockComponent;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;



/**
 * Event System used during a replay. It works almost the same as EventSystemImpl, with most methods being exactly the
 * same, with the exception of 'send' and 'process'. On the 'process' method, the recorded events are loaded from a file
 * to the RecordedEventStore and then they are processed for a certain amount of time. The 'send' filters which events can
 * be sent by the engine during a replay. This is important to ensure that the recorded events are replayed correctly
 * and that the player does not interfere with the replay.
 */
public class EventSystemReplayImpl implements EventSystem {

<span class="fc" id="L82">    private static final Logger logger = LoggerFactory.getLogger(EventSystemReplayImpl.class);</span>

<span class="fc" id="L84">    private Map&lt;Class&lt;? extends Event&gt;, SetMultimap&lt;Class&lt;? extends Component&gt;, EventHandlerInfo&gt;&gt; componentSpecificHandlers = Maps.newHashMap();</span>
<span class="fc" id="L85">    private SetMultimap&lt;Class&lt;? extends Event&gt;, EventSystemReplayImpl.EventHandlerInfo&gt; generalHandlers = HashMultimap.create();</span>
<span class="fc" id="L86">    private Comparator&lt;EventHandlerInfo&gt; priorityComparator = new EventSystemReplayImpl.EventHandlerPriorityComparator();</span>

    // Event metadata
<span class="fc" id="L89">    private BiMap&lt;SimpleUri, Class&lt;? extends Event&gt;&gt; eventIdMap = HashBiMap.create();</span>
<span class="fc" id="L90">    private SetMultimap&lt;Class&lt;? extends Event&gt;, Class&lt;? extends Event&gt;&gt; childEvents = HashMultimap.create();</span>

    private Thread mainThread;
<span class="fc" id="L93">    private BlockingQueue&lt;PendingEvent&gt; pendingEvents = Queues.newLinkedBlockingQueue();</span>
<span class="fc" id="L94">    private BlockingQueue&lt;RecordedEvent&gt; recordedEvents = Queues.newLinkedBlockingQueue();</span>

    private EventLibrary eventLibrary;
    private NetworkSystem networkSystem;

    //Event replaying
    /** if the recorded events were loaded from the RecordedEventStore. */
    private boolean areRecordedEventsLoaded;
    /** When the events were loaded. Used to reproduce the events at the correct time. */
    private long replayEventsLoadTime;
    /** Necessary to do some entity id mapping from original client and replay client. */
    private EngineEntityManager entityManager;
    /** Where the RecordedEvents are deserialized */
    private RecordedEventStore recordedEventStore;
    /** Class responsible for deserializing recorded data */
    private RecordAndReplaySerializer recordAndReplaySerializer;
    /** Responsible for knowing the game name of the recording */
    private RecordAndReplayUtils recordAndReplayUtils;
    /** List of classes selected to replay */
    private List&lt;Class&lt;?&gt;&gt; selectedClassesToReplay;
    /** The current Status of Record And Replay */
    private RecordAndReplayCurrentStatus recordAndReplayCurrentStatus;
    /** The position of the last recorded event processed */
    private long lastRecordedEventIndex;


    public EventSystemReplayImpl(EventLibrary eventLibrary, NetworkSystem networkSystem, EngineEntityManager entityManager,
                                 RecordedEventStore recordedEventStore, RecordAndReplaySerializer recordAndReplaySerializer,
                                 RecordAndReplayUtils recordAndReplayUtils, List&lt;Class&lt;?&gt;&gt; selectedClassesToReplay,
<span class="fc" id="L123">                                 RecordAndReplayCurrentStatus recordAndReplayCurrentStatus) {</span>
<span class="fc" id="L124">        this.mainThread = Thread.currentThread();</span>
<span class="fc" id="L125">        this.eventLibrary = eventLibrary;</span>
<span class="fc" id="L126">        this.networkSystem = networkSystem;</span>
<span class="fc" id="L127">        this.entityManager = entityManager;</span>
<span class="fc" id="L128">        this.recordedEventStore = recordedEventStore;</span>
<span class="fc" id="L129">        this.recordAndReplaySerializer = recordAndReplaySerializer;</span>
<span class="fc" id="L130">        this.recordAndReplayUtils = recordAndReplayUtils;</span>
<span class="fc" id="L131">        this.selectedClassesToReplay = selectedClassesToReplay;</span>
<span class="fc" id="L132">        this.recordAndReplayCurrentStatus = recordAndReplayCurrentStatus;</span>
<span class="fc" id="L133">    }</span>

    /**
     * Fills recordedEvents with the events in RecordedEventStore.
     */
    private void fillRecordedEvents() {
<span class="fc" id="L139">        Collection&lt;RecordedEvent&gt; events = recordedEventStore.getEvents();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (RecordedEvent event : events) {</span>
<span class="fc" id="L141">            this.recordedEvents.offer(event);</span>
<span class="fc" id="L142">        }</span>
<span class="fc" id="L143">    }</span>

    // send method of EventSystemImpl
    private void originalSend(EntityRef entity, Event event) {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (Thread.currentThread() != mainThread) {</span>
<span class="nc" id="L148">            pendingEvents.offer(new PendingEvent(entity, event));</span>
        } else {
<span class="fc" id="L150">            networkReplicate(entity, event);</span>

<span class="fc" id="L152">            Set&lt;EventHandlerInfo&gt; selectedHandlersSet = selectEventHandlers(event.getClass(), entity);</span>
<span class="fc" id="L153">            List&lt;EventHandlerInfo&gt; selectedHandlers = Lists.newArrayList(selectedHandlersSet);</span>
<span class="fc" id="L154">            selectedHandlers.sort(priorityComparator);</span>

<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (event instanceof ConsumableEvent) {</span>
<span class="fc" id="L157">                sendConsumableEvent(entity, event, selectedHandlers);</span>
            } else {
<span class="nc" id="L159">                sendStandardEvent(entity, event, selectedHandlers);</span>
            }
        }
<span class="fc" id="L162">    }</span>

    // send method of EventSystemImpl
    private void originalSend(EntityRef entity, Event event, Component component) {

<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (Thread.currentThread() != mainThread) {</span>
<span class="nc" id="L168">            pendingEvents.offer(new PendingEvent(entity, event, component));</span>
        } else {
<span class="nc" id="L170">            SetMultimap&lt;Class&lt;? extends Component&gt;, EventSystemReplayImpl.EventHandlerInfo&gt; handlers = componentSpecificHandlers.get(event.getClass());</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (handlers != null) {</span>
<span class="nc" id="L172">                List&lt;EventSystemReplayImpl.EventHandlerInfo&gt; eventHandlers = Lists.newArrayList(handlers.get(component.getClass()));</span>
<span class="nc" id="L173">                eventHandlers.sort(priorityComparator);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                for (EventSystemReplayImpl.EventHandlerInfo eventHandler : eventHandlers) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                    if (eventHandler.isValidFor(entity)) {</span>
<span class="nc" id="L176">                        eventHandler.invoke(entity, event);</span>
                    }
<span class="nc" id="L178">                }</span>
            }
        }
<span class="nc" id="L181">    }</span>

    /**
     * Processes recorded and pending events. If recordedEvents is not loaded, load it from RecordedEventStore.
     */
    @Override
    public void process() {
<span class="fc" id="L188">        processRecordedEvents();</span>
<span class="fc" id="L189">        PendingEvent event = pendingEvents.poll();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        while (event != null) {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (event.getComponent() != null) {</span>
<span class="nc" id="L192">                originalSend(event.getEntity(), event.getEvent(), event.getComponent());</span>
            } else {
<span class="nc" id="L194">                originalSend(event.getEntity(), event.getEvent());</span>
            }
<span class="nc" id="L196">            event = pendingEvents.poll();</span>
        }
<span class="fc" id="L198">    }</span>

    /**
     * Processes recorded events for a certain amount of time and only if the timestamp is right.
     */
    private void processRecordedEvents() {
<span class="fc bfc" id="L204" title="All 4 branches covered.">        if (recordAndReplayCurrentStatus.getStatus() == RecordAndReplayStatus.REPLAYING &amp;&amp; !this.areRecordedEventsLoaded) {</span>
<span class="fc" id="L205">            initialiseReplayData();</span>
        }
        //If replay is ready, process some recorded events if the time is right.
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (recordAndReplayCurrentStatus.getStatus() == RecordAndReplayStatus.REPLAYING) {</span>
<span class="fc" id="L209">            processRecordedEventsBatch(1);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (this.recordedEvents.isEmpty()) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                if (recordAndReplayUtils.getFileCount() &lt;= recordAndReplayUtils.getFileAmount()) { //Get next recorded events file</span>
<span class="nc" id="L212">                    loadNextRecordedEventFile();</span>
                } else {
<span class="fc" id="L214">                    finishReplay();</span>
                }
            }
        }
<span class="fc" id="L218">    }</span>

    /**
     * Empty the RecordedEventStore and sets the RecordAndReplayStatus.
     */
    private void finishReplay() {
<span class="fc" id="L224">        recordedEventStore.popEvents();</span>
<span class="fc" id="L225">        recordAndReplayCurrentStatus.setStatus(RecordAndReplayStatus.REPLAY_FINISHED); // stops the replay if every recorded event was already replayed</span>
<span class="fc" id="L226">    }</span>

    private void loadNextRecordedEventFile() {
<span class="nc" id="L229">        String recordingPath = PathManager.getInstance().getRecordingPath(recordAndReplayUtils.getGameTitle()).toString();</span>
<span class="nc" id="L230">        recordAndReplaySerializer.deserializeRecordedEvents(recordingPath);</span>
<span class="nc" id="L231">        fillRecordedEvents();</span>
<span class="nc" id="L232">    }</span>

    private void initialiseReplayData() {
<span class="fc" id="L235">        fillRecordedEvents();</span>
<span class="fc" id="L236">        this.areRecordedEventsLoaded = true;</span>
<span class="fc" id="L237">        logger.info(&quot;Loaded Recorded Events!&quot;);</span>
<span class="fc" id="L238">        replayEventsLoadTime = System.currentTimeMillis();</span>
<span class="fc" id="L239">    }</span>

    /**
     * Try to process recorded events for 'maxDuration' miliseconds. Events are only processed if the time is right.
     * @param maxDuration the amount of time in which this method will try to process recorded events in one go.
     */
    private void processRecordedEventsBatch(long maxDuration) {
<span class="fc" id="L246">        long beginTime = System.currentTimeMillis();</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (RecordedEvent re = recordedEvents.peek(); re != null; re = recordedEvents.peek()) {</span>
<span class="fc" id="L248">            long passedTime = System.currentTimeMillis() - this.replayEventsLoadTime;</span>
            //Waits until the time of reproduction is right or until 'maxDuration' miliseconds have already passed since this method was called
<span class="fc bfc" id="L250" title="All 2 branches covered.">            while (passedTime &lt; re.getTimestamp()) {</span>
<span class="fc" id="L251">                passedTime = System.currentTimeMillis() - this.replayEventsLoadTime;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if ((System.currentTimeMillis() - beginTime) &gt;= maxDuration) {</span>
<span class="fc" id="L253">                    return;</span>
                }
            }
<span class="fc" id="L256">            recordedEvents.poll();</span>
<span class="fc" id="L257">            EntityRef entity = getEntityRef(re);</span>
            // Sends recorded event to be processed
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            if (re.getComponent() != null) {</span>
<span class="nc" id="L260">                originalSend(entity, re.getEvent(), re.getComponent());</span>
            } else {
<span class="fc" id="L262">                originalSend(entity, re.getEvent());</span>
            }
<span class="fc" id="L264">            this.lastRecordedEventIndex = re.getIndex();</span>
            // Check if time is up.
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            if ((System.currentTimeMillis() - beginTime) &gt;= maxDuration) {</span>
<span class="nc" id="L267">                return;</span>
            }
        }
<span class="fc" id="L270">    }</span>

    /**
     * Since only the EntityRef's id is saved in the RecordedEvent, it is necessary to get the real EntityRef when
     * processing a RecordedEvent.
     * @param recordedEvent The recorded event containing the ID of the entity to be gotten.
     * @return the EntityRef with the id recorded in the RecordedEvent.
     */
    private EntityRef getEntityRef(RecordedEvent recordedEvent) {
<span class="fc" id="L279">        return this.entityManager.getEntity(recordedEvent.getEntityId());</span>
    }

    @Override
    public void registerEvent(SimpleUri uri, Class&lt;? extends Event&gt; eventType) {
<span class="nc" id="L284">        eventIdMap.put(uri, eventType);</span>
<span class="nc" id="L285">        logger.debug(&quot;Registering event {}&quot;, eventType.getSimpleName());</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (Class parent : ReflectionUtils.getAllSuperTypes(eventType, Predicates.assignableFrom(Event.class))) {</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">            if (!AbstractConsumableEvent.class.equals(parent) &amp;&amp; !Event.class.equals(parent)) {</span>
<span class="nc" id="L288">                childEvents.put(parent, eventType);</span>
            }
<span class="nc" id="L290">        }</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (shouldAddToLibrary(eventType)) {</span>
<span class="nc" id="L292">            eventLibrary.register(uri, eventType);</span>
        }
<span class="nc" id="L294">    }</span>

    /**
     * Events are added to the event library if they have a network annotation
     *
     * @param eventType the type of the event to be checked.
     * @return Whether the event should be added to the event library
     */
    private boolean shouldAddToLibrary(Class&lt;? extends Event&gt; eventType) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        return eventType.getAnnotation(ServerEvent.class) != null</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                || eventType.getAnnotation(OwnerEvent.class) != null</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                || eventType.getAnnotation(BroadcastEvent.class) != null;</span>
    }

    @Override
    public void registerEventHandler(ComponentSystem handler) {
<span class="fc" id="L310">        Class handlerClass = handler.getClass();</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (!Modifier.isPublic(handlerClass.getModifiers())) {</span>
<span class="nc" id="L312">            logger.error(&quot;Cannot register handler {}, must be public&quot;, handler.getClass().getName());</span>
<span class="nc" id="L313">            return;</span>
        }

<span class="fc" id="L316">        logger.debug(&quot;Registering event handler &quot; + handlerClass.getName());</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (Method method : handlerClass.getMethods()) {</span>
<span class="fc" id="L318">            ReceiveEvent receiveEventAnnotation = method.getAnnotation(ReceiveEvent.class);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (receiveEventAnnotation != null) {</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">                if (!receiveEventAnnotation.netFilter().isValidFor(networkSystem.getMode(), false)) {</span>
<span class="nc" id="L321">                    continue;</span>
                }
<span class="fc" id="L323">                Set&lt;Class&lt;? extends Component&gt;&gt; requiredComponents = Sets.newLinkedHashSet();</span>
<span class="fc" id="L324">                method.setAccessible(true);</span>
<span class="fc" id="L325">                Class&lt;?&gt;[] types = method.getParameterTypes();</span>

<span class="fc" id="L327">                logger.debug(&quot;Found method: &quot; + method.toString());</span>
<span class="pc bpc" id="L328" title="2 of 4 branches missed.">                if (!Event.class.isAssignableFrom(types[0]) || !EntityRef.class.isAssignableFrom(types[1])) {</span>
<span class="nc" id="L329">                    logger.error(&quot;Invalid event handler method: {}&quot;, method.getName());</span>
<span class="nc" id="L330">                    return;</span>
                }

<span class="fc" id="L333">                requiredComponents.addAll(Arrays.asList(receiveEventAnnotation.components()));</span>
<span class="fc" id="L334">                List&lt;Class&lt;? extends Component&gt;&gt; componentParams = Lists.newArrayList();</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                for (int i = 2; i &lt; types.length; ++i) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                    if (!Component.class.isAssignableFrom(types[i])) {</span>
<span class="nc" id="L337">                        logger.error(&quot;Invalid event handler method: {} - {} is not a component class&quot;, method.getName(), types[i]);</span>
<span class="nc" id="L338">                        return;</span>
                    }
<span class="nc" id="L340">                    requiredComponents.add((Class&lt;? extends Component&gt;) types[i]);</span>
<span class="nc" id="L341">                    componentParams.add((Class&lt;? extends Component&gt;) types[i]);</span>
                }

<span class="fc" id="L344">                EventSystemReplayImpl.ByteCodeEventHandlerInfo handlerInfo = new EventSystemReplayImpl.ByteCodeEventHandlerInfo(handler, method, receiveEventAnnotation.priority(),</span>
<span class="fc" id="L345">                        receiveEventAnnotation.activity(), requiredComponents, componentParams);</span>
<span class="fc" id="L346">                addEventHandler((Class&lt;? extends Event&gt;) types[0], handlerInfo, requiredComponents);</span>
            }
        }
<span class="fc" id="L349">    }</span>

    @Override
    public void unregisterEventHandler(ComponentSystem handler) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">        for (SetMultimap&lt;Class&lt;? extends Component&gt;, EventSystemReplayImpl.EventHandlerInfo&gt; eventHandlers : componentSpecificHandlers.values()) {</span>
<span class="nc" id="L354">            Iterator&lt;EventHandlerInfo&gt; eventHandlerIterator = eventHandlers.values().iterator();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            while (eventHandlerIterator.hasNext()) {</span>
<span class="nc" id="L356">                EventSystemReplayImpl.EventHandlerInfo eventHandler = eventHandlerIterator.next();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                if (eventHandler.getHandler().equals(handler)) {</span>
<span class="nc" id="L358">                    eventHandlerIterator.remove();</span>
                }
<span class="nc" id="L360">            }</span>
<span class="nc" id="L361">        }</span>

<span class="nc" id="L363">        Iterator&lt;EventSystemReplayImpl.EventHandlerInfo&gt; eventHandlerIterator = generalHandlers.values().iterator();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        while (eventHandlerIterator.hasNext()) {</span>
<span class="nc" id="L365">            EventSystemReplayImpl.EventHandlerInfo eventHandler = eventHandlerIterator.next();</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (eventHandler.getHandler().equals(handler)) {</span>
<span class="nc" id="L367">                eventHandlerIterator.remove();</span>
            }
<span class="nc" id="L369">        }</span>
<span class="nc" id="L370">    }</span>

    private void addEventHandler(Class&lt;? extends Event&gt; type, EventSystemReplayImpl.EventHandlerInfo handler, Collection&lt;Class&lt;? extends Component&gt;&gt; components) {
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (components.isEmpty()) {</span>
<span class="fc" id="L374">            generalHandlers.put(type, handler);</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">            for (Class&lt;? extends Event&gt; childType : childEvents.get(type)) {</span>
<span class="nc" id="L376">                generalHandlers.put(childType, handler);</span>
<span class="pc" id="L377">            }</span>
        } else {
<span class="nc bnc" id="L379" title="All 2 branches missed.">            for (Class&lt;? extends Component&gt; c : components) {</span>
<span class="nc" id="L380">                addToComponentSpecificHandlers(type, handler, c);</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                for (Class&lt;? extends Event&gt; childType : childEvents.get(type)) {</span>
<span class="nc" id="L382">                    addToComponentSpecificHandlers(childType, handler, c);</span>
<span class="nc" id="L383">                }</span>
<span class="nc" id="L384">            }</span>
        }
<span class="fc" id="L386">    }</span>

    private void addToComponentSpecificHandlers(Class&lt;? extends Event&gt; type, EventSystemReplayImpl.EventHandlerInfo handlerInfo, Class&lt;? extends Component&gt; c) {
<span class="nc" id="L389">        SetMultimap&lt;Class&lt;? extends Component&gt;, EventSystemReplayImpl.EventHandlerInfo&gt; componentMap = componentSpecificHandlers.get(type);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (componentMap == null) {</span>
<span class="nc" id="L391">            componentMap = HashMultimap.create();</span>
<span class="nc" id="L392">            componentSpecificHandlers.put(type, componentMap);</span>
        }
<span class="nc" id="L394">        componentMap.put(c, handlerInfo);</span>
<span class="nc" id="L395">    }</span>

    @Override
    public &lt;T extends Event&gt; void registerEventReceiver(EventReceiver&lt;T&gt; eventReceiver, Class&lt;T&gt; eventClass, Class&lt;? extends Component&gt;... componentTypes) {
<span class="nc" id="L399">        registerEventReceiver(eventReceiver, eventClass, EventPriority.PRIORITY_NORMAL, componentTypes);</span>
<span class="nc" id="L400">    }</span>

    @Override
    public &lt;T extends Event&gt; void registerEventReceiver(EventReceiver&lt;T&gt; eventReceiver, Class&lt;T&gt; eventClass, int priority, Class&lt;? extends Component&gt;... componentTypes) {
<span class="nc" id="L404">        EventSystemReplayImpl.EventHandlerInfo info = new EventSystemReplayImpl.ReceiverEventHandlerInfo&lt;&gt;(eventReceiver, priority, componentTypes);</span>
<span class="nc" id="L405">        addEventHandler(eventClass, info, Arrays.asList(componentTypes));</span>
<span class="nc" id="L406">    }</span>

    @Override
    public &lt;T extends Event&gt; void unregisterEventReceiver(EventReceiver&lt;T&gt; eventReceiver, Class&lt;T&gt; eventClass, Class&lt;? extends Component&gt;... componentTypes) {
<span class="nc" id="L410">        SetMultimap&lt;Class&lt;? extends Component&gt;, EventSystemReplayImpl.EventHandlerInfo&gt; eventHandlerMap = componentSpecificHandlers.get(eventClass);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (eventHandlerMap != null) {</span>
<span class="nc" id="L412">            EventSystemReplayImpl.ReceiverEventHandlerInfo testReceiver = new EventSystemReplayImpl.ReceiverEventHandlerInfo&lt;&gt;(eventReceiver, 0, componentTypes);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            for (Class&lt;? extends Component&gt; c : componentTypes) {</span>
<span class="nc" id="L414">                eventHandlerMap.remove(c, testReceiver);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                for (Class&lt;? extends Event&gt; childType : childEvents.get(eventClass)) {</span>
<span class="nc" id="L416">                    eventHandlerMap.remove(childType, testReceiver);</span>
<span class="nc" id="L417">                }</span>
            }
        }

<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (0 == componentTypes.length) {</span>
<span class="nc" id="L422">            Iterator&lt;EventSystemReplayImpl.EventHandlerInfo&gt; eventHandlerIterator = generalHandlers.values().iterator();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            while (eventHandlerIterator.hasNext()) {</span>
<span class="nc" id="L424">                EventSystemReplayImpl.EventHandlerInfo eventHandler = eventHandlerIterator.next();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (eventHandler.getHandler().equals(eventReceiver)) {</span>
<span class="nc" id="L426">                    eventHandlerIterator.remove();</span>
                }
<span class="nc" id="L428">            }</span>
        }
<span class="nc" id="L430">    }</span>

    /**
     * Calls the 'process' method if the replay is activated and the event is of a type selected to be replayed.
     * This way, events of the types that are recorded and replayed are ignored during a replay. This is what makes
     * the player have no control over the character during a replay.
     * @param entity the entity which the event was sent against.
     * @param event the event being sent.
     */
    @Override
    public void send(EntityRef entity, Event event) {
<span class="fc bfc" id="L441" title="All 4 branches covered.">        if (recordAndReplayCurrentStatus.getStatus() != RecordAndReplayStatus.REPLAYING || !isSelectedToReplayEvent(event)) {</span>
<span class="fc" id="L442">            originalSend(entity, event);</span>
        }
<span class="fc" id="L444">    }</span>

    /**
     * Calls the 'process' method if the replay is activated and the event is of a type selected to be replayed.
     * This way, events of the types that are recorded and replayed are ignored during a replay. This is what makes
     * the player have no control over the character during a replay.
     * @param entity the entity which the event was sent against.
     * @param event the event being sent.
     * @param component the component sent along with the event.
     */
    @Override
    public void send(EntityRef entity, Event event, Component component) {
<span class="nc bnc" id="L456" title="All 4 branches missed.">        if (recordAndReplayCurrentStatus.getStatus() != RecordAndReplayStatus.REPLAYING || !isSelectedToReplayEvent(event)) {</span>
<span class="nc" id="L457">            originalSend(entity, event, component);</span>
        }
<span class="nc" id="L459">    }</span>

    /**
     * Check if the event is selected to be replayed. If they are, they are only processed through replay and sending them
     * normally won't have any effect. Example: Since MouseWheelEvent is selected to replay, during the replay process
     * if the player moves the mouse wheel, the MouseWheelEvents generated won't be processed, but the ones on the recorded
     * events list will.
     * @param event event to be checked
     * @return if the event is selected to replay
     */
    private boolean isSelectedToReplayEvent(Event event) {
<span class="fc" id="L470">        boolean selectedToReplay = false;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        for (Class&lt;?&gt; supportedEventClass : this.selectedClassesToReplay) {</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">            if (supportedEventClass.isInstance(event)) {</span>
<span class="fc" id="L473">                selectedToReplay = true;</span>
<span class="fc" id="L474">                break;</span>
            }
<span class="fc" id="L476">        }</span>
<span class="fc" id="L477">        return selectedToReplay;</span>

    }

    private void sendStandardEvent(EntityRef entity, Event event, List&lt;EventSystemReplayImpl.EventHandlerInfo&gt; selectedHandlers) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (EventSystemReplayImpl.EventHandlerInfo handler : selectedHandlers) {</span>
            // Check isValid at each stage in case components were removed.
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (handler.isValidFor(entity)) {</span>
<span class="nc" id="L485">                handler.invoke(entity, event);</span>
            }
<span class="nc" id="L487">        }</span>
<span class="nc" id="L488">    }</span>

    private void sendConsumableEvent(EntityRef entity, Event event, List&lt;EventSystemReplayImpl.EventHandlerInfo&gt; selectedHandlers) {
<span class="fc" id="L491">        ConsumableEvent consumableEvent = (ConsumableEvent) event;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (EventSystemReplayImpl.EventHandlerInfo handler : selectedHandlers) {</span>
            // Check isValid at each stage in case components were removed.
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (handler.isValidFor(entity)) {</span>
<span class="fc" id="L495">                handler.invoke(entity, event);</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">                if (consumableEvent.isConsumed()) {</span>
<span class="nc" id="L497">                    return;</span>
                }
            }
<span class="fc" id="L500">        }</span>
<span class="fc" id="L501">    }</span>

    private void networkReplicate(EntityRef entity, Event event) {
<span class="fc" id="L504">        EventMetadata metadata = eventLibrary.getMetadata(event);</span>
<span class="pc bpc" id="L505" title="3 of 4 branches missed.">        if (metadata != null &amp;&amp; metadata.isNetworkEvent()) {</span>
<span class="nc" id="L506">            logger.debug(&quot;Replicating event: {}&quot;, event);</span>
<span class="nc bnc" id="L507" title="All 4 branches missed.">            switch (metadata.getNetworkEventType()) {</span>
                case BROADCAST:
<span class="nc" id="L509">                    broadcastEvent(entity, event, metadata);</span>
<span class="nc" id="L510">                    break;</span>
                case OWNER:
<span class="nc" id="L512">                    sendEventToOwner(entity, event);</span>
<span class="nc" id="L513">                    break;</span>
                case SERVER:
<span class="nc" id="L515">                    sendEventToServer(entity, event);</span>
<span class="nc" id="L516">                    break;</span>
                default:
                    break;
            }
        }
<span class="fc" id="L521">    }</span>

    private void sendEventToServer(EntityRef entity, Event event) {
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (networkSystem.getMode() == NetworkMode.CLIENT) {</span>
<span class="nc" id="L525">            NetworkComponent netComp = entity.getComponent(NetworkComponent.class);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (netComp != null) {</span>
<span class="nc" id="L527">                networkSystem.getServer().send(event, entity);</span>
            }
        }
<span class="nc" id="L530">    }</span>

    private void sendEventToOwner(EntityRef entity, Event event) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (networkSystem.getMode().isServer()) {</span>
<span class="nc" id="L534">            NetworkComponent netComp = entity.getComponent(NetworkComponent.class);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            if (netComp != null) {</span>
<span class="nc" id="L536">                Client client = networkSystem.getOwner(entity);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (client != null) {</span>
<span class="nc" id="L538">                    client.send(event, entity);</span>
                }
            }
        }
<span class="nc" id="L542">    }</span>

    private void broadcastEvent(EntityRef entity, Event event, EventMetadata metadata) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (networkSystem.getMode().isServer()) {</span>
<span class="nc" id="L546">            NetworkComponent netComp = entity.getComponent(NetworkComponent.class);</span>
<span class="nc" id="L547">            BlockComponent blockComp = entity.getComponent(BlockComponent.class);</span>
<span class="nc bnc" id="L548" title="All 4 branches missed.">            if (netComp != null || blockComp != null) {</span>
<span class="nc" id="L549">                Client instigatorClient = null;</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">                if (metadata.isSkipInstigator() &amp;&amp; event instanceof NetworkEvent) {</span>
<span class="nc" id="L551">                    instigatorClient = networkSystem.getOwner(((NetworkEvent) event).getInstigator());</span>
                }
<span class="nc bnc" id="L553" title="All 2 branches missed.">                for (Client client : networkSystem.getPlayers()) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    if (!client.equals(instigatorClient)) {</span>
<span class="nc" id="L555">                        client.send(event, entity);</span>
                    }
<span class="nc" id="L557">                }</span>
            }
        }
<span class="nc" id="L560">    }</span>


    private Set&lt;EventSystemReplayImpl.EventHandlerInfo&gt; selectEventHandlers(Class&lt;? extends Event&gt; eventType, EntityRef entity) {
<span class="fc" id="L564">        Set&lt;EventSystemReplayImpl.EventHandlerInfo&gt; result = Sets.newHashSet();</span>
<span class="fc" id="L565">        result.addAll(generalHandlers.get(eventType));</span>
<span class="fc" id="L566">        SetMultimap&lt;Class&lt;? extends Component&gt;, EventSystemReplayImpl.EventHandlerInfo&gt; handlers = componentSpecificHandlers.get(eventType);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (handlers == null) {</span>
<span class="fc" id="L568">            return result;</span>
        }

<span class="nc bnc" id="L571" title="All 2 branches missed.">        for (Class&lt;? extends Component&gt; compClass : handlers.keySet()) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (entity.hasComponent(compClass)) {</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                for (EventSystemReplayImpl.EventHandlerInfo eventHandler : handlers.get(compClass)) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                    if (eventHandler.isValidFor(entity)) {</span>
<span class="nc" id="L575">                        result.add(eventHandler);</span>
                    }
<span class="nc" id="L577">                }</span>
            }
<span class="nc" id="L579">        }</span>
<span class="nc" id="L580">        return result;</span>
    }

    public long getLastRecordedEventIndex() {
<span class="nc" id="L584">        return lastRecordedEventIndex;</span>
    }

    private static class EventHandlerPriorityComparator implements Comparator&lt;EventSystemReplayImpl.EventHandlerInfo&gt; {

        @Override
        public int compare(EventSystemReplayImpl.EventHandlerInfo o1, EventSystemReplayImpl.EventHandlerInfo o2) {
<span class="nc" id="L591">            return o2.getPriority() - o1.getPriority();</span>
        }
    }

    private interface EventHandlerInfo {
        boolean isValidFor(EntityRef entity);

        void invoke(EntityRef entity, Event event);

        int getPriority();

        Object getHandler();
    }

    private static class ByteCodeEventHandlerInfo implements EventSystemReplayImpl.EventHandlerInfo {
        private ComponentSystem handler;
        private String activity;
        private MethodAccess methodAccess;
        private int methodIndex;
        private ImmutableList&lt;Class&lt;? extends Component&gt;&gt; filterComponents;
        private ImmutableList&lt;Class&lt;? extends Component&gt;&gt; componentParams;
        private int priority;

        ByteCodeEventHandlerInfo(ComponentSystem handler,
                                 Method method,
                                 int priority,
                                 String activity,
                                 Collection&lt;Class&lt;? extends Component&gt;&gt; filterComponents,
<span class="fc" id="L619">                                 Collection&lt;Class&lt;? extends Component&gt;&gt; componentParams) {</span>


<span class="fc" id="L622">            this.handler = handler;</span>
<span class="fc" id="L623">            this.activity = activity;</span>
<span class="fc" id="L624">            this.methodAccess = MethodAccess.get(handler.getClass());</span>
<span class="fc" id="L625">            methodIndex = methodAccess.getIndex(method.getName(), method.getParameterTypes());</span>
<span class="fc" id="L626">            this.filterComponents = ImmutableList.copyOf(filterComponents);</span>
<span class="fc" id="L627">            this.componentParams = ImmutableList.copyOf(componentParams);</span>
<span class="fc" id="L628">            this.priority = priority;</span>
<span class="fc" id="L629">        }</span>

        @Override
        public boolean isValidFor(EntityRef entity) {
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            for (Class&lt;? extends Component&gt; component : filterComponents) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (!entity.hasComponent(component)) {</span>
<span class="nc" id="L635">                    return false;</span>
                }
<span class="nc" id="L637">            }</span>
<span class="fc" id="L638">            return true;</span>
        }

        @Override
        public void invoke(EntityRef entity, Event event) {
            try {
<span class="fc" id="L644">                Object[] params = new Object[2 + componentParams.size()];</span>
<span class="fc" id="L645">                params[0] = event;</span>
<span class="fc" id="L646">                params[1] = entity;</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">                for (int i = 0; i &lt; componentParams.size(); ++i) {</span>
<span class="nc" id="L648">                    params[i + 2] = entity.getComponent(componentParams.get(i));</span>
                }
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                if (!activity.isEmpty()) {</span>
<span class="nc" id="L651">                    PerformanceMonitor.startActivity(activity);</span>
                }
                try {
<span class="fc" id="L654">                    methodAccess.invoke(handler, methodIndex, params);</span>
                } finally {
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">                    if (!activity.isEmpty()) {</span>
<span class="nc" id="L657">                        PerformanceMonitor.endActivity();</span>
                    }
                }
<span class="nc" id="L660">            } catch (Exception ex) {</span>
<span class="nc" id="L661">                logger.error(&quot;Failed to invoke event&quot;, ex);</span>
<span class="fc" id="L662">            }</span>
<span class="fc" id="L663">        }</span>

        @Override
        public int getPriority() {
<span class="nc" id="L667">            return priority;</span>
        }

        @Override
        public ComponentSystem getHandler() {
<span class="nc" id="L672">            return handler;</span>
        }
    }

    private static class ReceiverEventHandlerInfo&lt;T extends Event&gt; implements EventSystemReplayImpl.EventHandlerInfo {
        private EventReceiver&lt;T&gt; receiver;
        private Class&lt;? extends Component&gt;[] components;
        private int priority;

<span class="nc" id="L681">        ReceiverEventHandlerInfo(EventReceiver&lt;T&gt; receiver, int priority, Class&lt;? extends Component&gt;... components) {</span>
<span class="nc" id="L682">            this.receiver = receiver;</span>
<span class="nc" id="L683">            this.priority = priority;</span>
<span class="nc" id="L684">            this.components = Arrays.copyOf(components, components.length);</span>
<span class="nc" id="L685">        }</span>

        @Override
        public boolean isValidFor(EntityRef entity) {
<span class="nc bnc" id="L689" title="All 2 branches missed.">            for (Class&lt;? extends Component&gt; component : components) {</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">                if (!entity.hasComponent(component)) {</span>
<span class="nc" id="L691">                    return false;</span>
                }
            }
<span class="nc" id="L694">            return true;</span>
        }

        @Override
        public void invoke(EntityRef entity, Event event) {
<span class="nc" id="L699">            receiver.onEvent((T) event, entity);</span>
<span class="nc" id="L700">        }</span>

        @Override
        public int getPriority() {
<span class="nc" id="L704">            return priority;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (obj == this) {</span>
<span class="nc" id="L710">                return true;</span>
            }
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (obj instanceof EventSystemReplayImpl.ReceiverEventHandlerInfo) {</span>
<span class="nc" id="L713">                EventSystemReplayImpl.ReceiverEventHandlerInfo other = (EventSystemReplayImpl.ReceiverEventHandlerInfo) obj;</span>
<span class="nc" id="L714">                return Objects.equal(receiver, other.receiver);</span>
            }
<span class="nc" id="L716">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L721">            return Objects.hashCode(receiver);</span>
        }

        @Override
        public Object getHandler() {
<span class="nc" id="L726">            return receiver;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>