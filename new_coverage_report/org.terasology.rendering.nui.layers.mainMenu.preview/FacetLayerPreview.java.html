<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FacetLayerPreview.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Terasology$engine_tests_with_JaCoCo.exec</a> &gt; <a href="index.source.html" class="el_package">org.terasology.rendering.nui.layers.mainMenu.preview</a> &gt; <span class="el_source">FacetLayerPreview.java</span></div><h1>FacetLayerPreview.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015 MovingBlocks
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.terasology.rendering.nui.layers.mainMenu.preview;

import com.google.common.math.IntMath;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.terasology.math.Region3i;
import org.terasology.math.geom.ImmutableVector2i;
import org.terasology.math.geom.Rect2i;
import org.terasology.math.geom.Vector3i;
import org.terasology.module.ModuleEnvironment;
import org.terasology.rendering.assets.texture.TextureData;
import org.terasology.rendering.nui.layers.mainMenu.ProgressListener;
import org.terasology.world.chunks.ChunkConstants;
import org.terasology.world.generation.Region;
import org.terasology.world.generation.World;
import org.terasology.world.generation.WorldFacet;
import org.terasology.world.generator.WorldGenerator;
import org.terasology.world.viewer.TileThreadFactory;
import org.terasology.world.viewer.color.ColorModels;
import org.terasology.world.viewer.layers.FacetLayer;
import org.terasology.world.viewer.layers.FacetLayers;
import org.terasology.world.viewer.layers.Renders;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.awt.image.DirectColorModel;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.math.RoundingMode;
import java.nio.ByteBuffer;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * A world preview based on the facets that are generated by the {@link WorldGenerator}
 * and a collection of {@link FacetLayer}, each annotated with
 * {@link org.terasology.world.viewer.layers.Renders} to display them.
 */
public class FacetLayerPreview implements PreviewGenerator {

<span class="nc" id="L69">    private static final Logger logger = LoggerFactory.getLogger(FacetLayerPreview.class);</span>

    private static final int TILE_SIZE_X = ChunkConstants.SIZE_X * 2;
    private static final int TILE_SIZE_Y = ChunkConstants.SIZE_Z * 2;

<span class="nc" id="L74">    private final DirectColorModel colorModel = ColorModels.RGBA;</span>

    private final WorldGenerator worldGenerator;

    private final List&lt;FacetLayer&gt; facetLayers;

<span class="nc" id="L80">    private ExecutorService threadPool = Executors.newFixedThreadPool(</span>
<span class="nc" id="L81">            Runtime.getRuntime().availableProcessors(),</span>
            new TileThreadFactory());


<span class="nc" id="L85">    public FacetLayerPreview(WorldGenerator worldGenerator, List&lt;FacetLayer&gt; facetLayers) {</span>
<span class="nc" id="L86">        this.worldGenerator = worldGenerator;</span>
<span class="nc" id="L87">        this.facetLayers = facetLayers.stream()</span>
<span class="nc" id="L88">                .sorted(Comparator.comparingInt(layer -&gt; layer.getClass().getAnnotation(Renders.class).order()))</span>
<span class="nc" id="L89">                .collect(Collectors.toList());</span>
<span class="nc" id="L90">    }</span>

<span class="nc" id="L92">    public FacetLayerPreview(ModuleEnvironment environment, WorldGenerator worldGenerator) {</span>
<span class="nc" id="L93">        this.worldGenerator = worldGenerator;</span>

<span class="nc" id="L95">        World world = worldGenerator.getWorld();</span>
<span class="nc" id="L96">        Set&lt;Class&lt;? extends WorldFacet&gt;&gt; facets = world.getAllFacets();</span>
<span class="nc" id="L97">        facetLayers = FacetLayers.createLayersFor(facets, environment);</span>
<span class="nc" id="L98">    }</span>

    @Override
    public ByteBuffer render(TextureData texData, int scale, ProgressListener progressListener) throws InterruptedException {
<span class="nc" id="L102">        int width = texData.getWidth();</span>
<span class="nc" id="L103">        int height  = texData.getWidth();</span>
<span class="nc" id="L104">        final int offX = -width * scale / 2;</span>
<span class="nc" id="L105">        final int offY = -height * scale / 2;</span>

<span class="nc" id="L107">        worldGenerator.getWorld(); // trigger building the World now</span>

<span class="nc" id="L109">        Rect2i worldArea = Rect2i.createFromMinAndSize(offX, offY, width * scale, height * scale);</span>
<span class="nc" id="L110">        Rect2i tileArea = worldToTileArea(worldArea);</span>
<span class="nc" id="L111">        AtomicInteger tilesComplete = new AtomicInteger(0);</span>
<span class="nc" id="L112">        int tileCount = tileArea.area();</span>

<span class="nc" id="L114">        int[] masks = colorModel.getMasks();</span>
<span class="nc" id="L115">        DataBufferInt imageBuffer = new DataBufferInt(width * height);</span>
<span class="nc" id="L116">        WritableRaster raster = Raster.createPackedRaster(imageBuffer, width, height, width, masks, null);</span>
<span class="nc" id="L117">        BufferedImage view = new BufferedImage(colorModel, raster, false, null);</span>

<span class="nc" id="L119">        Graphics2D g = view.createGraphics();</span>
<span class="nc" id="L120">        g.scale(1f / scale, 1f / scale);</span>
<span class="nc" id="L121">        g.translate(-offX, -offY);</span>
<span class="nc" id="L122">        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span>

<span class="nc" id="L124">        Map&lt;ImmutableVector2i, Future&lt;BufferedImage&gt;&gt; imageFutures = new HashMap&lt;&gt;(tileCount);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        for (int z = tileArea.minY(); z &lt; tileArea.maxY(); z++) {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">            for (int x = tileArea.minX(); x &lt; tileArea.maxX(); x++) {</span>
<span class="nc" id="L127">                ImmutableVector2i pos = new ImmutableVector2i(x, z);</span>
<span class="nc" id="L128">                imageFutures.put(pos, threadPool.submit(() -&gt; {</span>
<span class="nc" id="L129">                    Region createRegion = createRegion(pos);</span>
<span class="nc" id="L130">                    BufferedImage image = rasterize(createRegion);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                    if (progressListener != null) {</span>
<span class="nc" id="L132">                        progressListener.onProgress(tilesComplete.incrementAndGet() / (float) tileCount);</span>
                    }
<span class="nc" id="L134">                    return image;</span>
                }));
            }
        }

<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (int z = tileArea.minY(); z &lt; tileArea.maxY(); z++) {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            for (int x = tileArea.minX(); x &lt; tileArea.maxX(); x++) {</span>
<span class="nc" id="L141">                ImmutableVector2i pos = new ImmutableVector2i(x, z);</span>
                try {
<span class="nc" id="L143">                    BufferedImage tileImage = imageFutures.get(pos).get();</span>
<span class="nc" id="L144">                    g.drawImage(tileImage, x * TILE_SIZE_X, z * TILE_SIZE_Y, null);</span>
<span class="nc" id="L145">                } catch (ExecutionException e) {</span>
<span class="nc" id="L146">                    logger.warn(&quot;Could not rasterize tile {}&quot;, pos, e);</span>
<span class="nc" id="L147">                }</span>

<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (Thread.currentThread().isInterrupted()) {</span>
<span class="nc" id="L150">                    throw new InterruptedException();</span>
                }
            }
        }

        // draw coordinate lines through 0 / 0
<span class="nc" id="L156">        g.setColor(Color.GRAY);</span>
<span class="nc" id="L157">        g.drawLine(worldArea.minX(), 0, worldArea.maxX(), 0);</span>
<span class="nc" id="L158">        g.drawLine(0, worldArea.minY(), 0, worldArea.maxY());</span>

<span class="nc" id="L160">        g.dispose();</span>

<span class="nc" id="L162">        int[] data = imageBuffer.getData();</span>
<span class="nc" id="L163">        ByteBuffer byteBuffer = texData.getBuffers()[0];</span>
<span class="nc" id="L164">        byteBuffer.asIntBuffer().put(data);</span>

<span class="nc" id="L166">        return byteBuffer;</span>
    }

    @Override
    public void close() {
<span class="nc" id="L171">        threadPool.shutdown();</span>
<span class="nc" id="L172">    }</span>

    private Region createRegion(ImmutableVector2i chunkPos) {

<span class="nc" id="L176">        int vertChunks = 4; // 4 chunks high (relevant for trees, etc)</span>

<span class="nc" id="L178">        int minX = chunkPos.getX() * TILE_SIZE_X;</span>
<span class="nc" id="L179">        int minZ = chunkPos.getY() * TILE_SIZE_Y;</span>
<span class="nc" id="L180">        int height = vertChunks * ChunkConstants.SIZE_Y;</span>
<span class="nc" id="L181">        Region3i area3d = Region3i.createFromMinAndSize(new Vector3i(minX, 0, minZ), new Vector3i(TILE_SIZE_X, height, TILE_SIZE_Y));</span>
<span class="nc" id="L182">        World world = worldGenerator.getWorld();</span>
<span class="nc" id="L183">        Region region = world.getWorldData(area3d);</span>
<span class="nc" id="L184">        return region;</span>
    }

    private static Rect2i worldToTileArea(Rect2i area) {
<span class="nc" id="L188">        int chunkMinX = IntMath.divide(area.minX(), TILE_SIZE_X, RoundingMode.FLOOR);</span>
<span class="nc" id="L189">        int chunkMinZ = IntMath.divide(area.minY(), TILE_SIZE_Y, RoundingMode.FLOOR);</span>

<span class="nc" id="L191">        int chunkMaxX = IntMath.divide(area.maxX(), TILE_SIZE_X, RoundingMode.CEILING);</span>
<span class="nc" id="L192">        int chunkMaxZ = IntMath.divide(area.maxY(), TILE_SIZE_Y, RoundingMode.CEILING);</span>

<span class="nc" id="L194">        return Rect2i.createFromMinAndMax(chunkMinX, chunkMinZ, chunkMaxX, chunkMaxZ);</span>
    }

    /**
     * Note: this method must be thread-safe!
     * @param region the thread-safe region
     * @return an image of that region
     */
    private BufferedImage rasterize(Region region) {

<span class="nc" id="L204">        Vector3i extent = region.getRegion().size();</span>
<span class="nc" id="L205">        int width = extent.x;</span>
<span class="nc" id="L206">        int height = extent.z;</span>

<span class="nc" id="L208">        WritableRaster raster = colorModel.createCompatibleWritableRaster(width, height);</span>
<span class="nc" id="L209">        BufferedImage image = new BufferedImage(colorModel, raster, false, null);</span>

<span class="nc" id="L211">        Graphics2D g = image.createGraphics();</span>
<span class="nc" id="L212">        g.setColor(Color.BLACK);</span>
<span class="nc" id="L213">        g.fillRect(0, 0, width, height);</span>

        try {
<span class="nc" id="L216">            facetLayers.stream().filter(FacetLayer::isVisible).forEach(layer -&gt; layer.render(image, region));</span>
        } finally {
<span class="nc" id="L218">            g.dispose();</span>
        }

<span class="nc" id="L221">        return image;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>